\documentclass{scrreprt}

\usepackage{graphicx}
\usepackage{tikz}
\usepackage{amstext}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{textcomp}
\usepackage[left=2.5cm, right=2.5cm, top=2cm, bottom=2cm]{geometry}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\hypersetup{
  colorlinks=false,
  linkbordercolor=blue,
  pdfborderstyle={/S/U/W 0}
}
\title{\textbf{Algorithmen und Datenstrukturen}}
\author{\href{https://github.com/bircni}{\color{blue}github/bircni}}
%\date{\href{https://ko-fi.com/toiletcoders}{\color{black}little donation}}
\begin{document}
\pagenumbering{gobble}
\maketitle
\pagebreak
\renewcommand{\contentsname}{Inhaltsverzeichnis}
%\renewcommand{\cftdot}{}
\setcounter{tocdepth}{1}
\tableofcontents
\addtocontents{toc}{~\hfill\textbf{Seite}\par}
\pagebreak
%\pagenumbering{arabic}
\chapter{Mathematische Grundlagen}
\section{Reihen}
\includegraphics[width=0.65\textwidth]{graphics/reihen-arithmetisch}
\section{Potenzen und Logarithmen}
Der Logarithmus ist die Inverse der Potenzfunktion. $\log_a(x) = y \quad \Longleftrightarrow  \quad a^y = x$
\\\textbf{spezielle Logarithmen:}
\\$ld(x)=log_2(x)$, $lg(x)=log_10(x)$, $ln(x)=log_e(x)$
\section{Notationskonventionen}
$\lceil x \rceil$ zur nächsten ganzen Zahl aufrunden
\\$\lfloor x \rfloor$ zur nächsten ganzen Zahl abrunden
\\$[a .. b] = {x \arrowvert a \leq x \wedge x \leq b}$ mit Intervallgrenzen
\\$]a .. b[ = {x \arrowvert a < x \wedge x < b}$ ohne Intervallgrenzen
\\$arr[i .. k]$ Teilfolge der Elemente von $arr[i]$ bis $arr[k]$
\section{Grundbegriffe der Graphentheorie}
Graphen bestehen aus einer Menge von Knoten und Kanten, die diese verbinden.
\\Ein Graph ist gerichtet, wenn die Kanten eine Richtung haben.
\\Für einen Knoten v eines gerichteten Graphen $G=(V,E)$ ist der Eingangsgrad $indeg(v)$ die Anzahl der Kanten,
die in v enden, und der Ausgangsgrad $outdeg(v)$ die Anzahl der Kanten, die von v ausgehen.
\\Ein Zyklus ist ein Weg der bei einem Knoten startet und endet.
\\Ein gerichteter Graph ist zusammenhängend, wenn es einen Weg zwischen jedem Knotenpaar gibt.
\\Ein Baum hat einen Knoten als Wurzel, jeder Knoten hat genau einen Vorgänger und ist zusammenhängend.
\\Ein Knoten ohne Kinder heißt Blatt. Ein leerer Baum hat die Höhe 0.
Ein Binärbaum ist ein Baum, dessen Knoten maximal zwei Kinder haben.
\\Traversierungen: Preorder (WLR), Inorder (LWR), Postorder (LRW)
\chapter{Rekursive Algorithmen}
\section{Prinzip der Rekursion}
Ein rekursiver Algorithmus besteht aus einem Basisfall und einem rekursiven Aufruf.
\\Der rekursive Aufruf muss immer kleiner werden, damit die Rekursion endet.
\\Die Rekursion kann durch eine Schleife ersetzt werden.
\begin{lstlisting}
  public static double sum_v2(double[] arr) {
  return sum_v2(arr, 0, arr.length-1);
  }
/** Berechnet Summe der Werte von arr[firstIndex..lastIndex] */
  private static double sum_v2(double[] arr, int firstIndex,int lastIndex) {
  if (firstIndex == lastIndex) {
    // zu summierender Bereich besteht nur aus einem Element
    return arr[firstIndex];
  }
  else {
    int mid = (firstIndex + lastIndex) / 2;
    return sum_v2(arr, firstIndex, mid) + sum_v2(arr, mid+1, lastIndex);
  }}
  \end{lstlisting}
\section{Korrektheit rekursiver Algorithmen}
Ein Beweisverfahren ist die Berechnungsinduktion.
\\\includegraphics[width=0.8\textwidth]{graphics/3-2Korrektheit}
\section{Rekursive Berechnung der Potenzmenge}
\textbf{Beispiel:}
\\Menge: $M =\{a,b,c\}$
\\Potenzmenge: $\rho (M) = \{ \emptyset, \{a\}, \{b\}, \{c\}, \{a,b\}, \{a,c\}, \{b,c\}, \{a,b,c\} \}$
\subsection{Rekursiver Lösungsansatz}
a) in welchen einfach Fällen kann die Lösung direkt angegeben werden?
\\\tab der einfachste Fall ist die leere Menge $M = \emptyset$
\\\tab die leere Menge hat nur sich als Teilmenge $\rho(\emptyset) = \{\emptyset\}$
\\b) Wie können in nicht einfachen Fällen die Teilmengen bestimmt werden?
\\\tab Sei Menge $M = \{a_1,\ldots,a_{n-1},a_n\}$ nicht leer $(n\geq1)$
\begin{itemize}
  \item [1.] Wir wählen ein Element der Menge, z.B. $a_n$
  \item [2.] Es gibt nun zwei Arten von Teilmengen:
  \begin{itemize}
    \item [$T^+$] Teilmengen, die das Element $a_n$ enthalten
    \item [$T^-$] Teilmengen, die das Element $a_n$ nicht enthalten
  \end{itemize}
  Die Menge aller Teilmengen ist die Vereinigung von $T^+$ und $T^-$, d.h. $\rho(M) = T^+ \cup T^-$
  \\Die Menge $T^+$ kann nun rekursiv berechnet werden, indem wir $a_n$ aus $M$ entfernen und die Potenzmenge von $M$ berechnen.
  \\Die Menge $T^-$ ist die Potenzmenge von $M$ ohne $a_n$.
  \\Die Potenzmenge von $M$ ist also die Vereinigung von $T^+$ und $T^-$.
\end{itemize}
\textbf{Beispiel:} Wenn $M = \{a,b,c\}$
\\\tab Wähle z.B. c als Element:
\\\tab $T^-$: alle Teilmengen ohne c, also alle Teilmengen von $\{a,b\}$
\\\tab\tab $T^- =\{\emptyset,\{a\},\{b\},\{a,b\}\}$
\\\tab $T^+$: alle Teilmengen mit c, Nimm zu jeder Teilmenge von $T^-$ und füge c hinzu
\\\tab\tab $T^+ = \{\{c\},\{a,c\},\{b,c\},\{a,b,c\}\}$
\\\tab Insgesamt: $\rho(\{M\}) = T^+ \cup T^- =\{\emptyset,\{a\},\{b\},\{a,b\},\{c\},\{a,c\},\{b,c\},\{a,b,c\}\}$
\subsection{Algorithmischer Ansatz}
\textbf{Falls M leer} ($M = \emptyset$)
\\\tab leere Menge ist die einzige Teilmenge
\\\textbf{Falls M nicht leer} Wähle ein Element $a_n$ aus $M$
\\\tab Berechne Sammlung $T^-$ aller Teilmengen von M ohne $a_n$ (rekursiv)
\\\tab Berechne Sammlung $T^+$ aller Teilmengen, die $a_n$ enthalten:
\\\tab Nimm dazu jede Menge aus $T^-$ und bilde eine neue Menge, indem $a_n$ hinzugefügt wird
\\\tab Die Menge aller Teilmengen ist die Vereinigung von $T^+$ und $T^-$
\\\begin{lstlisting}
private static <E> Set<Set<E>> allSubsets(E[] arr,int maxIndex) {
Set<Set<E>> resultSet = new HashSet<Set<E>>();
if (maxIndex >= 0) {
  // Menge ist nicht leer, waehle letzes Element im gegebenen Bereich
E selected = arr[maxIndex];
  // Bilde rekursive alle Teilmengen ohne selected
Set<Set<E>> resultSet1 = allSubsets(arr, maxIndex - 1);
  // nimm jede dieser Mengen zum Ergebnis hinzu
resultSet.addAll(resultSet1);
  // bilde alle Teilmengen, die selected enthalten
for (Set<E> set1 : resultSet1) {
  // Erzeuge Kopie der Menge aus resultSet1 und nimm gewaehltes Element dazu
Set<E> set2 = new HashSet<E>(set1);
set2.add(selected);
  // fuege die ergaenzte Kopie zum Ergebnis hinzu
resultSet.add(set2);
}
} else {
  // Menge ist leer. Leere Menge hat nur leere Menge als einzige Teilmenge
Set<E> emptySet = new HashSet<>();
resultSet.add(emptySet);
}
return resultSet;
}
\end{lstlisting}
\section{Algorithmenprinzip ''Backtracking''}
\end{document}